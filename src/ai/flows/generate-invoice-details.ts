
'use server';
/**
 * @fileOverview Generates structured invoice details from a textual description, including line items, customer details, and payment terms.
 *
 * - generateInvoiceDetails - A function that handles parsing invoice descriptions.
 * - GenerateInvoiceDetailsInput - The input type for the function.
 * - GenerateInvoiceDetailsOutput - The return type for the function.
 */

import {ai} from '@/ai/genkit';
import { z } from 'genkit';

const GenerateInvoiceDetailsInputSchema = z.object({
  description: z.string().describe('A textual description of the invoice, e.g., "Invoice Client Corp for 10 hours of consulting at $50/hour and 2 licenses for Product X at $100 each, due in 30 days, project XYZ. Send to client@example.com, billing address: 123 Main St, Anytown. Shipping to 456 Oak Ave."'),
});
export type GenerateInvoiceDetailsInput = z.infer<typeof GenerateInvoiceDetailsInputSchema>;

const LineItemSchema = z.object({
  description: z.string().describe('Description of the item or service.'),
  quantity: z.coerce.number().min(0.01).optional().default(1).describe('Quantity of the item/service. Default to 1 if not specified.'),
  unitPrice: z.coerce.number().min(0).optional().default(0).describe('Price per unit of the item/service (pre-tax).'),
  amount: z.coerce.number().min(0).optional().describe('Taxable amount for this line item (quantity * unitPrice). If not derivable, AI may estimate based on context or overall total.'),
  hsnSacCode: z.string().optional().describe('HSN or SAC code for the item/service, if discernible.'),
  gstRate: z.coerce.number().min(0).max(100).optional().describe('Applicable GST rate for this item as a percentage (e.g., 18 for 18%).'),
});

const GenerateInvoiceDetailsOutputSchema = z.object({
  customerName: z.string().optional().describe('The name of the customer or client.'),
  customerEmail: z.string().optional().describe("The customer's email address."),
  billingAddress: z.string().optional().describe("The customer's billing address."),
  shippingAddress: z.string().optional().describe("The customer's shipping address (if different from billing)."),
  
  invoiceNumber: z.string().optional().describe("The invoice number, if mentioned. Otherwise can be generated by the system later."),
  invoiceDate: z.string().optional().describe("The date of the invoice (YYYY-MM-DD). If not specified, use today's date."),
  dueDate: z.string().optional().describe("The due date for the invoice (YYYY-MM-DD). Calculate if terms like 'Net 30' or 'due in 30 days' are mentioned relative to the invoice date."),
  paymentTerms: z.string().optional().describe("Payment terms (e.g., 'Net 30', 'Due on receipt')."),
  
  itemsSummary: z.string().optional().describe('A brief textual summary of the items or services being invoiced. Provide this if structured line items cannot be reliably extracted.'),
  lineItems: z.array(LineItemSchema).optional().describe('An array of structured line items for the invoice. Populate this if the description allows for clear itemization.'),
  
  totalAmount: z.number().optional().describe('The total amount of the invoice, if explicitly mentioned and line items cannot be broken down. Prefer calculation from line items.'), 
  notes: z.string().optional().describe("Any additional notes or comments mentioned for the invoice."),
  customerGstin: z.string().optional().describe("The customer's GSTIN, if discernible."),
  status: z.enum(['draft', 'sent', 'paid', 'overdue', 'void']).optional().default('draft').describe("The status of the invoice."),


});
export type GenerateInvoiceDetailsOutput = z.infer<typeof GenerateInvoiceDetailsOutputSchema>;

export async function generateInvoiceDetails(input: GenerateInvoiceDetailsInput): Promise<GenerateInvoiceDetailsOutput> {
  return generateInvoiceDetailsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateInvoiceDetailsPrompt',
  model: 'googleai/gemini-1.5-flash-latest', // Using a more capable model for this complex task.
  input: {schema: GenerateInvoiceDetailsInputSchema},
  output: {schema: GenerateInvoiceDetailsOutputSchema},
  prompt: `You are a meticulous data extraction bot. Your one and only job is to parse the following user text and convert it into a structured JSON object.

**USER TEXT TO PARSE:**
"{{{description}}}"

**YOUR TASK: JSON FIELD MAPPING RULEBOOK**
You must follow these rules precisely.

- **Customer Details**:
  - \`customerName\`: Find the client's full name (e.g., "FutureTech Innovations Pvt Ltd.").
  - \`customerEmail\`: Find the client's email address (e.g., "accounts@futuretech.in").
  - \`billingAddress\`: Find the client's full billing address.
  - \`shippingAddress\`: Find the client's full shipping address. If it's not mentioned, leave the field empty.

- **Invoice Dates & Number**:
  - \`invoiceNumber\`: Find the invoice number (e.g., "INV-2024-001").
  - \`invoiceDate\`: Find the invoice date and format it as YYYY-MM-DD. If no year is mentioned, use the current year. If no date is mentioned, use today's date.
  - \`dueDate\`: Find the payment due date and format it as YYYY-MM-DD. You MUST calculate this from the \`invoiceDate\` if terms like "Net 15" or "due in 15 days" are present.

- **\`lineItems\` (CRITICAL):**
  - This MUST be an array of objects.
  - You MUST create one object for EACH distinct product or service mentioned (e.g., one for "software development", one for "cloud hosting licenses").
  - Each object MUST have \`description\`, \`quantity\`, and \`unitPrice\`.
  - You MUST strip currency symbols like 'â‚¹' or '$' from the \`unitPrice\`.
  - If a global tax rate is mentioned (e.g., "GST @18%"), you MUST set the \`gstRate\` field for ALL line items to that number (e.g., 18).

- **\`paymentTerms\` & \`notes\` (CRITICAL CATCH-ALL):**
  - \`paymentTerms\`: The full text of the payment terms. For example: "Net 15 days from invoice date. Late payments will incur a 2% monthly interest."
  - \`notes\`: This field MUST contain all of the following if they are present in the text:
    - **All Bank Details:** A/C No, IFSC, Bank Name, UPI IDs.
    - **Project Details:** Project names or reference numbers (e.g., "Project: Smart Inventory Dashboard Upgrade").
    - **Other Contacts:** Any secondary contact information, such as "For queries, contact billing@acmesoftware.in."

Now, generate the complete JSON object based on these strict rules. Do not omit any extractable information.
`,
});

const generateInvoiceDetailsFlow = ai.defineFlow(
  {
    name: 'generateInvoiceDetailsFlow',
    inputSchema: GenerateInvoiceDetailsInputSchema,
    outputSchema: GenerateInvoiceDetailsOutputSchema,
  },
  async (input: GenerateInvoiceDetailsInput) => {
    let {output} = await prompt(input);
    
    // START: Robust Post-Processing Logic
    
    // 1. Date Correction
    let processedInvoiceDate = output.invoiceDate;
    const today = new Date();
    const todayISO = today.toISOString().split('T')[0];

    const yearRegex = /\b(19|20)\d{2}\b/;
    const yearMentionedInInput = yearRegex.test(input.description);
    const aiYear = output.invoiceDate ? parseInt(output.invoiceDate.substring(0, 4), 10) : null;
    const currentYear = today.getFullYear();
    
    const isValidDateString = (dateStr: string | undefined): dateStr is string => !!dateStr && /^\d{4}-\d{2}-\d{2}$/.test(dateStr) && !isNaN(new Date(dateStr).getTime());

    if (aiYear && aiYear !== currentYear && !yearMentionedInInput) {
        try {
            const dateWithCurrentYear = new Date(output.invoiceDate!);
            dateWithCurrentYear.setFullYear(currentYear);
            processedInvoiceDate = dateWithCurrentYear.toISOString().split('T')[0];
        } catch(e) {
            console.warn(`Could not correct year for invoiceDate '${output.invoiceDate}'. Defaulting to today.`);
            processedInvoiceDate = todayISO;
        }
    } else if (!isValidDateString(processedInvoiceDate)) {
        console.warn(`AI returned invalid invoiceDate '${output.invoiceDate}' for input: "${input.description}". Defaulting to today: ${todayISO}.`);
        processedInvoiceDate = todayISO;
    }
    
    let finalOutput = { ...output, invoiceDate: processedInvoiceDate };

    // 2. Clean empty/null string fields to be undefined
    const stringFieldsToClean: (keyof GenerateInvoiceDetailsOutput)[] = ['customerName', 'customerEmail', 'billingAddress', 'shippingAddress', 'invoiceNumber', 'paymentTerms', 'itemsSummary', 'notes', 'customerGstin'];
    stringFieldsToClean.forEach(field => {
        if (finalOutput[field] === "" || finalOutput[field] === null) {
            (finalOutput as any)[field] = undefined;
        }
    });

    // 3. Process Line Items for correctness and calculation
    if (finalOutput.lineItems && finalOutput.lineItems.length > 0) {
      finalOutput.lineItems = finalOutput.lineItems.map(item => {
        const quantity = item.quantity === undefined || item.quantity === null || item.quantity <= 0 ? 1 : item.quantity;
        const unitPrice = item.unitPrice === undefined || item.unitPrice === null ? (item.amount || 0) / quantity : item.unitPrice;
        return {
            description: item.description || "N/A",
            quantity: quantity,
            unitPrice: unitPrice,
            amount: parseFloat((quantity * unitPrice).toFixed(2)), // Recalculate amount for consistency
            hsnSacCode: item.hsnSacCode,
            gstRate: item.gstRate,
        };
      });
      // If we have structured line items, these summary fields are redundant.
      finalOutput.totalAmount = undefined; 
      finalOutput.itemsSummary = undefined; 
    }

    // 4. Calculate Due Date from terms if not already parsed correctly
    if (finalOutput.invoiceDate && !isValidDateString(finalOutput.dueDate)) {
        const invDate = new Date(finalOutput.invoiceDate + 'T00:00:00Z'); // Ensure correct timezone handling
        if (input.description.match(/\b(Net ?30|due in 30 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 30);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        } else if (input.description.match(/\b(Net ?15|due in 15 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 15);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        }  else if (input.description.match(/\b(due end of month|due by EOM)\b/i)) {
            const lastDay = new Date(invDate.getFullYear(), invDate.getMonth() + 1, 0);
            finalOutput.dueDate = lastDay.toISOString().split('T')[0];
        } else {
           // If AI provided an invalid date string, clear it.
           finalOutput.dueDate = undefined;
        }
    }
    
    // 5. Default status
    if (finalOutput.status === null || finalOutput.status === "" || !finalOutput.status) {
        finalOutput.status = 'draft';
    }

    return finalOutput;
    // END: Robust Post-Processing Logic
  }
);

    