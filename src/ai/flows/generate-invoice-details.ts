
'use server';
/**
 * @fileOverview Generates structured invoice details from a textual description, including line items, customer details, and payment terms.
 *
 * - generateInvoiceDetails - A function that handles parsing invoice descriptions.
 * - GenerateInvoiceDetailsInput - The input type for the function.
 * - GenerateInvoiceDetailsOutput - The return type for the function.
 */

import {ai} from '@/ai/genkit';
import { z } from 'genkit';

const GenerateInvoiceDetailsInputSchema = z.object({
  description: z.string().describe('A textual description of the invoice, e.g., "Invoice Client Corp for 10 hours of consulting at $50/hour and 2 licenses for Product X at $100 each, due in 30 days, project XYZ. Send to client@example.com, billing address: 123 Main St, Anytown. Shipping to 456 Oak Ave."'),
});
export type GenerateInvoiceDetailsInput = z.infer<typeof GenerateInvoiceDetailsInputSchema>;

const LineItemSchema = z.object({
  description: z.string().describe('Description of the item or service.'),
  quantity: z.coerce.number().min(0.01).optional().default(1).describe('Quantity of the item/service. Default to 1 if not specified.'),
  unitPrice: z.coerce.number().min(0).optional().default(0).describe('Price per unit of the item/service (pre-tax).'),
  amount: z.coerce.number().min(0).optional().describe('Taxable amount for this line item (quantity * unitPrice). If not derivable, AI may estimate based on context or overall total.'),
  hsnSacCode: z.string().optional().describe('HSN or SAC code for the item/service, if discernible.'),
  gstRate: z.coerce.number().min(0).max(100).optional().describe('Applicable GST rate for this item as a percentage (e.g., 18 for 18%).'),
});

const GenerateInvoiceDetailsOutputSchema = z.object({
  customerName: z.string().optional().describe('The name of the customer or client.'),
  customerEmail: z.string().optional().describe("The customer's email address."),
  billingAddress: z.string().optional().describe("The customer's billing address."),
  shippingAddress: z.string().optional().describe("The customer's shipping address (if different from billing)."),
  
  invoiceNumber: z.string().optional().describe("The invoice number, if mentioned. Otherwise can be generated by the system later."),
  invoiceDate: z.string().optional().describe("The date of the invoice (YYYY-MM-DD). If not specified, use today's date."),
  dueDate: z.string().optional().describe("The due date for the invoice (YYYY-MM-DD). Calculate if terms like 'Net 30' or 'due in 30 days' are mentioned relative to the invoice date."),
  paymentTerms: z.string().optional().describe("Payment terms (e.g., 'Net 30', 'Due on receipt')."),
  
  itemsSummary: z.string().optional().describe('A brief textual summary of the items or services being invoiced. Provide this if structured line items cannot be reliably extracted.'),
  lineItems: z.array(LineItemSchema).optional().describe('An array of structured line items for the invoice. Populate this if the description allows for clear itemization.'),
  
  totalAmount: z.number().optional().describe('The total amount of the invoice, if explicitly mentioned and line items cannot be broken down. Prefer calculation from line items.'), 
  notes: z.string().optional().describe("Any additional notes or comments mentioned for the invoice."),
  customerGstin: z.string().optional().describe("The customer's GSTIN, if discernible."),
  status: z.enum(['draft', 'sent', 'paid', 'overdue', 'void']).optional().default('draft').describe("The status of the invoice."),


});
export type GenerateInvoiceDetailsOutput = z.infer<typeof GenerateInvoiceDetailsOutputSchema>;

export async function generateInvoiceDetails(input: GenerateInvoiceDetailsInput): Promise<GenerateInvoiceDetailsOutput> {
  return generateInvoiceDetailsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateInvoiceDetailsPrompt',
  input: {schema: GenerateInvoiceDetailsInputSchema},
  output: {schema: GenerateInvoiceDetailsOutputSchema},
  prompt: `You are a highly precise data extraction AI. Your task is to convert the following user-provided text into a structured JSON object. Every detail is important.

**USER TEXT:**
"{{{description}}}"

**JSON FIELD MAPPING RULES:**

- \`customerName\`: The name of the client being invoiced.
- \`customerEmail\`: The primary billing email address for the customer (e.g., accounts@... or contact@...).
- \`billingAddress\`: The customer's full billing address.
- \`shippingAddress\`: The customer's full shipping address.
- \`customerGstin\`: The customer's GSTIN.

- \`invoiceNumber\`: The unique invoice identifier.
- \`invoiceDate\`: The date the invoice was issued (Format: YYYY-MM-DD). If no year is given, use the current year. If no date, use today.
- \`dueDate\`: The payment due date (Format: YYYY-MM-DD). You MUST calculate this from \`invoiceDate\` if terms like "Net 15" or "due in 15 days" are present.
- \`status\`: Default to 'draft'.

- **\`lineItems\` (CRITICAL):**
  - This MUST be an array of objects.
  - Create one object for EACH distinct product/service.
  - Each object needs \`description\`, \`quantity\`, and \`unitPrice\`.
  - \`unitPrice\` should be a number; you MUST strip currency symbols like 'â‚¹' or '$'.
  - If a global tax rate is mentioned (e.g., "GST @18%"), set the \`gstRate\` field for ALL line items to that number (e.g., 18).

- \`paymentTerms\`: The full text of the payment terms, including any late fee policies.
- **\`notes\` (CRITICAL CATCH-ALL):**
  - This field MUST contain all of the following if present in the text:
    - **All Bank Details:** A/C No, IFSC, Bank Name, UPI IDs.
    - **Project Details:** Project names or reference numbers.
    - **Other Contacts:** Any query or secondary contact information.

Now, generate the complete JSON object based on these rules. Do not omit any extractable information.
`,
});

const generateInvoiceDetailsFlow = ai.defineFlow(
  {
    name: 'generateInvoiceDetailsFlow',
    inputSchema: GenerateInvoiceDetailsInputSchema,
    outputSchema: GenerateInvoiceDetailsOutputSchema,
  },
  async (input: GenerateInvoiceDetailsInput) => {
    let {output} = await prompt(input);
    
    let processedInvoiceDate = output.invoiceDate;
    const today = new Date();
    const todayISO = today.toISOString().split('T')[0];

    const yearRegex = /\b(19|20)\d{2}\b/;
    const yearMentionedInInput = yearRegex.test(input.description);
    const aiYear = output.invoiceDate ? parseInt(output.invoiceDate.substring(0, 4), 10) : null;
    const currentYear = today.getFullYear();
    
    const isValidDateString = (dateStr: string | undefined): dateStr is string => !!dateStr && /^\d{4}-\d{2}-\d{2}$/.test(dateStr) && !isNaN(new Date(dateStr).getTime());

    if (aiYear && aiYear !== currentYear && !yearMentionedInInput) {
        try {
            const dateWithCurrentYear = new Date(output.invoiceDate!);
            dateWithCurrentYear.setFullYear(currentYear);
            processedInvoiceDate = dateWithCurrentYear.toISOString().split('T')[0];
        } catch(e) {
            console.warn(`Could not correct year for invoiceDate '${output.invoiceDate}'. Defaulting to today.`);
            processedInvoiceDate = todayISO;
        }
    } else if (!isValidDateString(processedInvoiceDate)) {
        console.warn(`AI returned invalid invoiceDate '${output.invoiceDate}' for input: "${input.description}". Defaulting to today: ${todayISO}.`);
        processedInvoiceDate = todayISO;
    }
    
    let finalOutput = { ...output, invoiceDate: processedInvoiceDate };

    const stringFieldsToClean: (keyof GenerateInvoiceDetailsOutput)[] = ['customerName', 'customerEmail', 'billingAddress', 'shippingAddress', 'invoiceNumber', 'paymentTerms', 'itemsSummary', 'notes', 'customerGstin'];
    stringFieldsToClean.forEach(field => {
        if (finalOutput[field] === "" || finalOutput[field] === null) {
            (finalOutput as any)[field] = undefined;
        }
    });

    if (finalOutput.lineItems && finalOutput.lineItems.length > 0) {
      finalOutput.lineItems = finalOutput.lineItems.map(item => {
        const quantity = item.quantity === undefined || item.quantity === null || item.quantity <= 0 ? 1 : item.quantity;
        const unitPrice = item.unitPrice === undefined || item.unitPrice === null ? (item.amount || 0) / quantity : item.unitPrice;
        return {
            description: item.description || "N/A",
            quantity: quantity,
            unitPrice: unitPrice,
            amount: parseFloat((quantity * unitPrice).toFixed(2)),
            hsnSacCode: item.hsnSacCode,
            gstRate: item.gstRate,
        };
      });
      finalOutput.totalAmount = undefined; 
      finalOutput.itemsSummary = undefined; 
    }


    if (finalOutput.invoiceDate && !finalOutput.dueDate) {
        const invDate = new Date(finalOutput.invoiceDate + 'T00:00:00Z');
        if (input.description.match(/\b(Net ?30|due in 30 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 30);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        } else if (input.description.match(/\b(Net ?15|due in 15 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 15);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        }  else if (input.description.match(/\b(due end of month|due by EOM)\b/i)) {
            const lastDay = new Date(invDate.getFullYear(), invDate.getMonth() + 1, 0);
            finalOutput.dueDate = lastDay.toISOString().split('T')[0];
        }
    }
    if (finalOutput.dueDate && !/^\d{4}-\d{2}-\d{2}$/.test(finalOutput.dueDate)) {
        try {
             const parsedDueDate = new Date(finalOutput.dueDate);
             if (!isNaN(parsedDueDate.getTime()) && parsedDueDate.getFullYear() > 1970) {
                finalOutput.dueDate = parsedDueDate.toISOString().split('T')[0];
             } else {
                console.warn(`AI returned dueDate '${finalOutput.dueDate}' which is not valid. Removing.`);
                delete finalOutput.dueDate; 
             }
        } catch (e) {
            console.warn(`Error parsing dueDate '${finalOutput.dueDate}' from AI. Removing. Error: ${e}`);
            delete finalOutput.dueDate;
        }
    }
    
    if (finalOutput.status === null || finalOutput.status === "") {
        (finalOutput as any).status = undefined;
    }
    if (!finalOutput.status) {
        finalOutput.status = 'draft';
    }


    return finalOutput;
  }
);
