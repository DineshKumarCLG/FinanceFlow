
'use server';
/**
 * @fileOverview Generates structured invoice details from a textual description, including line items, customer details, and payment terms.
 *
 * - generateInvoiceDetails - A function that handles parsing invoice descriptions.
 * - GenerateInvoiceDetailsInput - The input type for the function.
 * - GenerateInvoiceDetailsOutput - The return type for the function.
 */

import {ai} from '@/ai/genkit';
import { z } from 'genkit';

const GenerateInvoiceDetailsInputSchema = z.object({
  description: z.string().describe('A textual description of the invoice, e.g., "Invoice Client Corp for 10 hours of consulting at $50/hour and 2 licenses for Product X at $100 each, due in 30 days, project XYZ. Send to client@example.com, billing address: 123 Main St, Anytown. Shipping to 456 Oak Ave."'),
});
export type GenerateInvoiceDetailsInput = z.infer<typeof GenerateInvoiceDetailsInputSchema>;

const LineItemSchema = z.object({
  description: z.string().describe('Description of the item or service.'),
  quantity: z.coerce.number().min(0.01).optional().default(1).describe('Quantity of the item/service. Default to 1 if not specified.'),
  unitPrice: z.coerce.number().min(0).optional().default(0).describe('Price per unit of the item/service (pre-tax).'),
  amount: z.coerce.number().min(0).optional().describe('Taxable amount for this line item (quantity * unitPrice). If not derivable, AI may estimate based on context or overall total.'),
  hsnSacCode: z.string().optional().describe('HSN or SAC code for the item/service, if discernible.'),
  gstRate: z.coerce.number().min(0).max(100).optional().describe('Applicable GST rate for this item as a percentage (e.g., 18 for 18%).'),
});

const GenerateInvoiceDetailsOutputSchema = z.object({
  customerName: z.string().optional().describe('The name of the customer or client.'),
  customerEmail: z.string().optional().describe("The customer's email address."),
  billingAddress: z.string().optional().describe("The customer's billing address."),
  shippingAddress: z.string().optional().describe("The customer's shipping address (if different from billing)."),
  
  invoiceNumber: z.string().optional().describe("The invoice number, if mentioned. Otherwise can be generated by the system later."),
  invoiceDate: z.string().optional().describe("The date of the invoice (YYYY-MM-DD). If not specified, use today's date."),
  dueDate: z.string().optional().describe("The due date for the invoice (YYYY-MM-DD). Calculate if terms like 'Net 30' or 'due in 30 days' are mentioned relative to the invoice date."),
  paymentTerms: z.string().optional().describe("Payment terms (e.g., 'Net 30', 'Due on receipt')."),
  
  itemsSummary: z.string().optional().describe('A brief textual summary of the items or services being invoiced. Provide this if structured line items cannot be reliably extracted.'),
  lineItems: z.array(LineItemSchema).optional().describe('An array of structured line items for the invoice. Populate this if the description allows for clear itemization.'),
  
  // subTotal, totalGstAmount, and totalAmount will be calculated by the application based on lineItems.
  // The AI can optionally provide a totalAmount if it's explicitly stated and no line items can be discerned.
  totalAmount: z.number().optional().describe('The total amount of the invoice, if explicitly mentioned and line items cannot be broken down. Prefer calculation from line items.'), 
  notes: z.string().optional().describe("Any additional notes or comments mentioned for the invoice."),
  // Added for consistency with manageInvoiceTool, though AI might not populate it directly
  customerGstin: z.string().optional().describe("The customer's GSTIN, if discernible."),
  status: z.enum(['draft', 'sent', 'paid', 'overdue', 'void']).optional().default('draft').describe("The status of the invoice."),


});
export type GenerateInvoiceDetailsOutput = z.infer<typeof GenerateInvoiceDetailsOutputSchema>;

export async function generateInvoiceDetails(input: GenerateInvoiceDetailsInput): Promise<GenerateInvoiceDetailsOutput> {
  return generateInvoiceDetailsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateInvoiceDetailsPrompt',
  input: {schema: GenerateInvoiceDetailsInputSchema},
  output: {schema: GenerateInvoiceDetailsOutputSchema},
  prompt: `You are a meticulous data extraction bot. Your sole purpose is to convert a text description of an invoice into a structured JSON object. You must follow all rules precisely and not miss any detail.

Analyze the following invoice description:
"{{{description}}}"

Now, extract the information according to these steps and rules.

**Step 1: Customer & Address Information**
- \`customerName\`: The name of the client or company being invoiced.
- \`customerEmail\`: The customer's primary email address for billing.
- \`customerGstin\`: The customer's GSTIN, if mentioned.
- \`billingAddress\`: The full billing address for the customer.
- \`shippingAddress\`: The full shipping address, if different from billing.

**Step 2: Invoice Metadata**
- \`invoiceNumber\`: Extract any invoice number mentioned (e.g., "INV-2024-001").
- \`invoiceDate\`: The date the invoice is issued. Format as YYYY-MM-DD.
- \`status\`: Default to 'draft' unless specified otherwise.

**Step 3: Line Items (CRITICAL)**
- You MUST prioritize creating structured \`lineItems\`.
- For each distinct product or service, create a separate line item object.
- For each item, extract:
  - \`description\`: The name of the service or product.
  - \`quantity\`: How many units. Default to 1 if not specified.
  - \`unitPrice\`: The cost per unit, before tax. Ignore currency symbols like 'â‚¹' or 'USD'.
  - \`hsnSacCode\`: The HSN or SAC code, if available.
- The \`amount\` field will be calculated later, so focus on quantity and unitPrice.
- Only use \`itemsSummary\` as a last resort if structured items are impossible to extract.

**Step 4: Financial & Payment Details**
- \`dueDate\`: The date payment is due. You MUST calculate this from the \`invoiceDate\` if terms like "Net 15", "due in 30 days" are mentioned. Format as YYYY-MM-DD.
- \`paymentTerms\`: Capture the full payment terms text (e.g., "Net 15 days from invoice date. Late payments will incur a 2% monthly interest.").
- **Tax Handling:** If a global tax rate (e.g., "GST @18%") is mentioned, you MUST apply this percentage to the \`gstRate\` field of *every single line item*.

**Step 5: Notes & Miscellaneous Information**
- \`notes\`: This is a catch-all for important information. You MUST place the following details here if they appear in the text:
    - **Bank Details:** Account number, IFSC/SWIFT codes, bank name, UPI IDs.
    - **Project Details:** Project names, codes, or reference numbers.
    - **Additional Contacts:** Any secondary contact information mentioned for queries.

**Final Date Handling Rules (Crucial):**
1.  For \`invoiceDate\`: Use the date mentioned in the text. If a year is not specified, assume the current calendar year. If no date is mentioned at all, use today's date.
2.  For \`dueDate\`: Calculate it based on \`invoiceDate\` and terms.
3.  **Format all dates as YYYY-MM-DD.**

Produce a valid JSON object conforming to the output schema. Be thorough.
`,
});

const generateInvoiceDetailsFlow = ai.defineFlow(
  {
    name: 'generateInvoiceDetailsFlow',
    inputSchema: GenerateInvoiceDetailsInputSchema,
    outputSchema: GenerateInvoiceDetailsOutputSchema,
  },
  async (input: GenerateInvoiceDetailsInput) => {
    let {output} = await prompt(input);
    
    let processedInvoiceDate = output.invoiceDate;
    const today = new Date();
    const todayISO = today.toISOString().split('T')[0];

    // Check if the AI hallucinated the year when it wasn't specified in the input.
    const yearRegex = /\b(19|20)\d{2}\b/;
    const yearMentionedInInput = yearRegex.test(input.description);
    const aiYear = output.invoiceDate ? parseInt(output.invoiceDate.substring(0, 4), 10) : null;
    const currentYear = today.getFullYear();
    
    const isValidDateString = (dateStr: string | undefined): dateStr is string => !!dateStr && /^\d{4}-\d{2}-\d{2}$/.test(dateStr) && !isNaN(new Date(dateStr).getTime());

    if (aiYear && aiYear !== currentYear && !yearMentionedInInput) {
        // AI likely hallucinated a year (e.g., its training year '2024') when none was provided.
        // Correct it to the current year.
        try {
            const dateWithCurrentYear = new Date(output.invoiceDate!);
            dateWithCurrentYear.setFullYear(currentYear);
            processedInvoiceDate = dateWithCurrentYear.toISOString().split('T')[0];
        } catch(e) {
            console.warn(`Could not correct year for invoiceDate '${output.invoiceDate}'. Defaulting to today.`);
            processedInvoiceDate = todayISO;
        }
    } else if (!isValidDateString(processedInvoiceDate)) {
        // If the date is invalid, a placeholder, or not provided, default to today.
        console.warn(`AI returned invalid invoiceDate '${output.invoiceDate}' for input: "${input.description}". Defaulting to today: ${todayISO}.`);
        processedInvoiceDate = todayISO;
    }
    
    let finalOutput = { ...output, invoiceDate: processedInvoiceDate };

    // Ensure all optional string fields that AI might return as "" or null are actually undefined if empty/null.
    const stringFieldsToClean: (keyof GenerateInvoiceDetailsOutput)[] = ['customerName', 'customerEmail', 'billingAddress', 'shippingAddress', 'invoiceNumber', 'paymentTerms', 'itemsSummary', 'notes', 'customerGstin'];
    stringFieldsToClean.forEach(field => {
        if (finalOutput[field] === "" || finalOutput[field] === null) {
            (finalOutput as any)[field] = undefined;
        }
    });

    if (finalOutput.lineItems && finalOutput.lineItems.length > 0) {
      finalOutput.lineItems = finalOutput.lineItems.map(item => {
        const quantity = item.quantity === undefined || item.quantity === null || item.quantity <= 0 ? 1 : item.quantity;
        const unitPrice = item.unitPrice === undefined || item.unitPrice === null ? (item.amount || 0) / quantity : item.unitPrice;
        return {
            description: item.description || "N/A",
            quantity: quantity,
            unitPrice: unitPrice,
            amount: parseFloat((quantity * unitPrice).toFixed(2)), // Recalculate amount as quantity * unitPrice
            hsnSacCode: item.hsnSacCode,
            gstRate: item.gstRate,
        };
      });
      finalOutput.totalAmount = undefined; 
      finalOutput.itemsSummary = undefined; 
    }


    // Basic due date calculation if invoice date is now set
    if (finalOutput.invoiceDate && !finalOutput.dueDate) {
        const invDate = new Date(finalOutput.invoiceDate + 'T00:00:00Z'); // Ensure parsing as UTC to avoid timezone shifts
        if (input.description.match(/\b(Net ?30|due in 30 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 30);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        } else if (input.description.match(/\b(Net ?15|due in 15 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 15);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        }  else if (input.description.match(/\b(due end of month|due by EOM)\b/i)) {
            const lastDay = new Date(invDate.getFullYear(), invDate.getMonth() + 1, 0);
            finalOutput.dueDate = lastDay.toISOString().split('T')[0];
        }
    }
    // Ensure due date is also YYYY-MM-DD if present and valid
    if (finalOutput.dueDate && !/^\d{4}-\d{2}-\d{2}$/.test(finalOutput.dueDate)) {
        try {
             const parsedDueDate = new Date(finalOutput.dueDate);
             if (!isNaN(parsedDueDate.getTime()) && parsedDueDate.getFullYear() > 1970) {
                finalOutput.dueDate = parsedDueDate.toISOString().split('T')[0];
             } else {
                console.warn(`AI returned dueDate '${finalOutput.dueDate}' which is not valid. Removing.`);
                delete finalOutput.dueDate; 
             }
        } catch (e) {
            console.warn(`Error parsing dueDate '${finalOutput.dueDate}' from AI. Removing. Error: ${e}`);
            delete finalOutput.dueDate;
        }
    }
    
    if (finalOutput.status === null || finalOutput.status === "") {
        (finalOutput as any).status = undefined; // Ensure status is undefined if empty/null
    }
    if (!finalOutput.status) { // If undefined or now explicitly undefined
        finalOutput.status = 'draft'; // Set default status if not provided by AI
    }


    return finalOutput;
  }
);
