
'use server';
/**
 * @fileOverview Generates structured invoice details from a textual description, including line items, customer details, and payment terms.
 *
 * - generateInvoiceDetails - A function that handles parsing invoice descriptions.
 * - GenerateInvoiceDetailsInput - The input type for the function.
 * - GenerateInvoiceDetailsOutput - The return type for the function.
 */

import {ai} from '@/ai/genkit';
import { z } from 'genkit';

const GenerateInvoiceDetailsInputSchema = z.object({
  description: z.string().describe('A textual description of the invoice, e.g., "Invoice Client Corp for 10 hours of consulting at $50/hour and 2 licenses for Product X at $100 each, due in 30 days, project XYZ. Send to client@example.com, billing address: 123 Main St, Anytown. Shipping to 456 Oak Ave."'),
});
export type GenerateInvoiceDetailsInput = z.infer<typeof GenerateInvoiceDetailsInputSchema>;

const LineItemSchema = z.object({
  description: z.string().describe('Description of the item or service.'),
  quantity: z.coerce.number().min(0.01).optional().default(1).describe('Quantity of the item/service. Default to 1 if not specified.'),
  unitPrice: z.coerce.number().min(0).optional().default(0).describe('Price per unit of the item/service (pre-tax).'),
  amount: z.coerce.number().min(0).describe('Taxable amount for this line item (quantity * unitPrice). If not derivable, AI may estimate based on context or overall total.'),
  hsnSacCode: z.string().optional().describe('HSN or SAC code for the item/service, if discernible.'),
  gstRate: z.coerce.number().min(0).max(100).optional().describe('Applicable GST rate for this item as a percentage (e.g., 18 for 18%).'),
});

const GenerateInvoiceDetailsOutputSchema = z.object({
  customerName: z.string().optional().describe('The name of the customer or client.'),
  customerEmail: z.string().email().optional().describe("The customer's email address."),
  billingAddress: z.string().optional().describe("The customer's billing address."),
  shippingAddress: z.string().optional().describe("The customer's shipping address (if different from billing)."),
  
  invoiceNumber: z.string().optional().describe("The invoice number, if mentioned. Otherwise can be generated by the system later."),
  invoiceDate: z.string().optional().describe("The date of the invoice (YYYY-MM-DD). If not specified, use today's date."),
  dueDate: z.string().optional().describe("The due date for the invoice (YYYY-MM-DD). Calculate if terms like 'Net 30' or 'due in 30 days' are mentioned relative to the invoice date."),
  paymentTerms: z.string().optional().describe("Payment terms (e.g., 'Net 30', 'Due on receipt')."),
  
  itemsSummary: z.string().optional().describe('A brief textual summary of the items or services being invoiced. Provide this if structured line items cannot be reliably extracted.'),
  lineItems: z.array(LineItemSchema).optional().describe('An array of structured line items for the invoice. Populate this if the description allows for clear itemization.'),
  
  // subTotal, totalGstAmount, and totalAmount will be calculated by the application based on lineItems.
  // The AI can optionally provide a totalAmount if it's explicitly stated and no line items can be discerned.
  totalAmount: z.number().optional().describe('The total amount of the invoice, if explicitly mentioned and line items cannot be broken down. Prefer calculation from line items.'), 
  notes: z.string().optional().describe("Any additional notes or comments mentioned for the invoice."),
  // Added for consistency with manageInvoiceTool, though AI might not populate it directly
  customerGstin: z.string().optional().describe("The customer's GSTIN, if discernible."),
  status: z.enum(['draft', 'sent', 'paid', 'overdue', 'void']).optional().default('draft').describe("The status of the invoice."),


});
export type GenerateInvoiceDetailsOutput = z.infer<typeof GenerateInvoiceDetailsOutputSchema>;

export async function generateInvoiceDetails(input: GenerateInvoiceDetailsInput): Promise<GenerateInvoiceDetailsOutput> {
  return generateInvoiceDetailsFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateInvoiceDetailsPrompt',
  input: {schema: GenerateInvoiceDetailsInputSchema},
  output: {schema: GenerateInvoiceDetailsOutputSchema},
  prompt: `You are an expert assistant that helps create invoices from textual descriptions.
Given the following invoice description:
"{{{description}}}"

Extract the following information:
- Customer Name: The name of the client or company being invoiced.
- Customer Email: The customer's email address.
- Billing Address: The full billing address for the customer.
- Shipping Address: The full shipping address, if different from billing.
- Customer GSTIN: The customer's GSTIN, if mentioned.
- Invoice Number: If an invoice number is mentioned.
- Invoice Date: The date the invoice is issued. If no date is mentioned, use today's date. Format as YYYY-MM-DD.
- Due Date: The date the payment is due. If terms like "Net 30", "due in 15 days", or "payment by end of month" are mentioned, calculate this relative to the invoice date. Format as YYYY-MM-DD. If no due date or terms are mentioned, you can leave this blank or suggest a common term like "Net 30".
- Payment Terms: Any payment terms mentioned (e.g., "Net 30", "Due upon receipt").
- Line Items: If the description contains clear itemization (e.g., "10 hours of consulting at $50/hour", "2 widgets at $20 each"), extract each as a structured line item with description, quantity, unitPrice (pre-tax), and calculated amount (taxable value: quantity * unitPrice). Attempt to identify HSN/SAC codes or GST rates if mentioned per item.
- Items Summary: If structured line items cannot be reliably extracted, provide a concise text summary of what is being invoiced (e.g., "Consulting services for Project XYZ", "Sale of 5 widgets").
- Total Amount: Only if the description explicitly states a total amount and line items cannot be reliably determined, provide this total. Otherwise, it will be calculated from line items.
- Notes: Any other relevant notes for the invoice.
- Status: Default to 'draft' unless specified otherwise.

**Date Handling Rules (Crucial):**
1. For Invoice Date: If the description explicitly mentions a specific date for the invoice itself (e.g., "invoice dated July 20th"), use that exact date.
2. **If a year is not specified in the description (e.g., "invoice dated July 20th"), assume the current calendar year.**
3. If no specific invoice date is mentioned at all, you MUST use the *current calendar date* (the date this request is being processed) as the invoiceDate.
4. For Due Date: Calculate based on terms from the invoice date. If "Net 30" or "due in 30 days", add 30 days to invoiceDate. If "due end of month", set to the last day of the invoiceDate's month. If no terms, suggest a 30-day due date or leave blank if uncertain.
5. **Format all dates as YYYY-MM-DD.**
6. **Do NOT default to a generic past date like "2024-01-01" for dates unless that specific date is explicitly mentioned in the input.**

**Line Item Rules:**
- 'unitPrice' should be the price before any taxes.
- 'amount' for each line item should be calculated as quantity * unitPrice (this is the taxable value for the line).
- If quantity or unitPrice is not explicitly mentioned for an item but can be inferred, use reasonable defaults (e.g., quantity 1).
- If the description only provides a total amount and a list of items without individual prices, you can try to create one line item with the total amount and list the items in its description, or provide an itemsSummary. Prioritize structured line items if possible.

Ensure the output is a valid JSON object conforming to the GenerateInvoiceDetailsOutputSchema.
If a field cannot be determined, omit it from the output or set to null/empty array where appropriate based on the schema.
Prioritize extracting structured 'lineItems' over 'itemsSummary'. If 'lineItems' are successfully extracted, 'itemsSummary' can be omitted or be a very brief overall title.
The main 'totalAmount' field in the output schema should ideally be left for the application to calculate from line items. Only populate it if the input description provides a grand total and line items are not extractable.
`,
});

const generateInvoiceDetailsFlow = ai.defineFlow(
  {
    name: 'generateInvoiceDetailsFlow',
    inputSchema: GenerateInvoiceDetailsInputSchema,
    outputSchema: GenerateInvoiceDetailsOutputSchema,
  },
  async (input: GenerateInvoiceDetailsInput) => {
    let {output} = await prompt(input);
    
    let processedInvoiceDate = output.invoiceDate;
    const today = new Date();
    const todayISO = today.toISOString().split('T')[0];

    // Check if the AI hallucinated the year when it wasn't specified in the input.
    const yearRegex = /\b(19|20)\d{2}\b/;
    const yearMentionedInInput = yearRegex.test(input.description);
    const aiYear = output.invoiceDate ? parseInt(output.invoiceDate.substring(0, 4), 10) : null;
    const currentYear = today.getFullYear();
    
    const isValidDateString = (dateStr: string | undefined): dateStr is string => !!dateStr && /^\d{4}-\d{2}-\d{2}$/.test(dateStr) && !isNaN(new Date(dateStr).getTime());

    if (aiYear && aiYear !== currentYear && !yearMentionedInInput) {
        // AI likely hallucinated a year (e.g., its training year '2024') when none was provided.
        // Correct it to the current year.
        try {
            const dateWithCurrentYear = new Date(output.invoiceDate!);
            dateWithCurrentYear.setFullYear(currentYear);
            processedInvoiceDate = dateWithCurrentYear.toISOString().split('T')[0];
        } catch(e) {
            console.warn(`Could not correct year for invoiceDate '${output.invoiceDate}'. Defaulting to today.`);
            processedInvoiceDate = todayISO;
        }
    } else if (!isValidDateString(processedInvoiceDate)) {
        // If the date is invalid, a placeholder, or not provided, default to today.
        console.warn(`AI returned invalid invoiceDate '${output.invoiceDate}' for input: "${input.description}". Defaulting to today: ${todayISO}.`);
        processedInvoiceDate = todayISO;
    }
    
    let finalOutput = { ...output, invoiceDate: processedInvoiceDate };

    // Ensure all optional string fields that AI might return as "" or null are actually undefined if empty/null.
    const stringFieldsToClean: (keyof GenerateInvoiceDetailsOutput)[] = ['customerName', 'customerEmail', 'billingAddress', 'shippingAddress', 'invoiceNumber', 'paymentTerms', 'itemsSummary', 'notes', 'customerGstin'];
    stringFieldsToClean.forEach(field => {
        if (finalOutput[field] === "" || finalOutput[field] === null) {
            (finalOutput as any)[field] = undefined;
        }
    });

    if (finalOutput.lineItems && finalOutput.lineItems.length > 0) {
      finalOutput.lineItems = finalOutput.lineItems.map(item => {
        const quantity = item.quantity === undefined || item.quantity === null || item.quantity <= 0 ? 1 : item.quantity;
        const unitPrice = item.unitPrice === undefined || item.unitPrice === null ? (item.amount || 0) / quantity : item.unitPrice;
        return {
            description: item.description || "N/A",
            quantity: quantity,
            unitPrice: unitPrice,
            amount: parseFloat((quantity * unitPrice).toFixed(2)), // Recalculate amount as quantity * unitPrice
            hsnSacCode: item.hsnSacCode,
            gstRate: item.gstRate,
        };
      });
      finalOutput.totalAmount = undefined; 
      finalOutput.itemsSummary = undefined; 
    }


    // Basic due date calculation if invoice date is now set
    if (finalOutput.invoiceDate && !finalOutput.dueDate) {
        const invDate = new Date(finalOutput.invoiceDate + 'T00:00:00Z'); // Ensure parsing as UTC to avoid timezone shifts
        if (input.description.match(/\b(Net ?30|due in 30 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 30);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        } else if (input.description.match(/\b(Net ?15|due in 15 days)\b/i)) {
            invDate.setDate(invDate.getDate() + 15);
            finalOutput.dueDate = invDate.toISOString().split('T')[0];
        }  else if (input.description.match(/\b(due end of month|due by EOM)\b/i)) {
            const lastDay = new Date(invDate.getFullYear(), invDate.getMonth() + 1, 0);
            finalOutput.dueDate = lastDay.toISOString().split('T')[0];
        }
    }
    // Ensure due date is also YYYY-MM-DD if present and valid
    if (finalOutput.dueDate && !/^\d{4}-\d{2}-\d{2}$/.test(finalOutput.dueDate)) {
        try {
             const parsedDueDate = new Date(finalOutput.dueDate);
             if (!isNaN(parsedDueDate.getTime()) && parsedDueDate.getFullYear() > 1970) {
                finalOutput.dueDate = parsedDueDate.toISOString().split('T')[0];
             } else {
                console.warn(`AI returned dueDate '${finalOutput.dueDate}' which is not valid. Removing.`);
                delete finalOutput.dueDate; 
             }
        } catch (e) {
            console.warn(`Error parsing dueDate '${finalOutput.dueDate}' from AI. Removing. Error: ${e}`);
            delete finalOutput.dueDate;
        }
    }
    
    if (finalOutput.status === null || finalOutput.status === "") {
        (finalOutput as any).status = undefined; // Ensure status is undefined if empty/null
    }
    if (!finalOutput.status) { // If undefined or now explicitly undefined
        finalOutput.status = 'draft'; // Set default status if not provided by AI
    }


    return finalOutput;
  }
);
